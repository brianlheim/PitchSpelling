exploreTree(
   Array<SpelledPitchClass> spcs,
   int nodeAndEdgeCost, 
   Array<SpelledPitchClass> solution, 
   int thresh,
   Array<PitchClass> pcs
)


i <= spcs.size
pc <= pcs[i]

[if we're at the base case (i = pcs.size) and under the threshold then set the solution to be the current graph (=spcs)]

[otherwise...]
spellings <= possibleSpellings(pc)
costs <= Array<(SpelledPitchClass, int, int)>

for each spelling in spellings
  calculate cost of (spcs + spelling) for nodeAndEdgeCost and graphCost
  costs <= (spelling, nodeAndEdgeCost, graphCost)

sort costs by (nodeAndEdgeCost + graphCost)

for each (spelling, nodeAndEdgeCost, graphCost) in costs
  ...
  [if we're still under the threshold, recurse]
  
end
